// Code generated by schema-generate. DO NOT EDIT.

package parser

import (
    "bytes"
    "encoding/json"
    "fmt"
    "errors"
)

// Concurrency 
type Concurrency struct {

  // To cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
  CancelInProgress bool `yaml:"cancel-in-progress,omitempty"`

  // When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled.
  Group string `yaml:"group"`
}

// Defaults 
type Defaults struct {
  Run *Run `yaml:"run,omitempty"`
}

// Env 
type Env struct {
  AdditionalProperties map[string]interface{} `yaml:"-,omitempty"`
}

// Environment The environment that the job references
type Environment struct {

  // The name of the environment configured in the repo.
  Name string `yaml:"name"`

  // A deployment URL
  Url string `yaml:"url,omitempty"`
}

// Jobs A workflow run is made up of one or more jobs. Jobs run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.
// Each job runs in a fresh instance of the virtual environment specified by runs-on.
// You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#usage-limits.
type Jobs struct {
}

// Root 
type Root struct {

  // Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the secrets context. 
  // You can also specify concurrency at the workflow level. 
  // When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
  Concurrency interface{} `yaml:"concurrency,omitempty"`

  // A map of default settings that will apply to all jobs in the workflow.
  Defaults *Defaults `yaml:"defaults,omitempty"`

  // A map of environment variables that are available to all jobs and steps in the workflow.
  Env *Env `yaml:"env,omitempty"`

  // A workflow run is made up of one or more jobs. Jobs run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.
  // Each job runs in a fresh instance of the virtual environment specified by runs-on.
  // You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#usage-limits.
  Jobs *Jobs `yaml:"jobs"`

  // The name of your workflow. GitHub displays the names of your workflows on your repository's actions page. If you omit this field, GitHub sets the name to the workflow's filename.
  Name string `yaml:"name,omitempty"`

  // The name of the GitHub event that triggers the workflow. You can provide a single event string, array of events, array of event types, or an event configuration map that schedules a workflow or restricts the execution of a workflow to specific files, tags, or branch changes. For a list of available events, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows.
  On interface{} `yaml:"on"`
  Permissions interface{} `yaml:"permissions,omitempty"`
}

// Run 
type Run struct {
  Shell string `yaml:"shell,omitempty"`
  WorkingDirectory string `yaml:"working-directory,omitempty"`
}

func (strct *Concurrency) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "cancel-in-progress" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"cancel-in-progress\": ")
	if tmp, err := json.Marshal(strct.CancelInProgress); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Group" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "group" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"group\": ")
	if tmp, err := json.Marshal(strct.Group); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Concurrency) UnmarshalJSON(b []byte) error {
    groupReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "cancel-in-progress":
            if err := json.Unmarshal([]byte(v), &strct.CancelInProgress); err != nil {
                return err
             }
        case "group":
            if err := json.Unmarshal([]byte(v), &strct.Group); err != nil {
                return err
             }
            groupReceived = true
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if group (a required property) was received
    if !groupReceived {
        return errors.New("\"group\" is required but was not present")
    }
    return nil
}

func (strct *Defaults) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "run" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"run\": ")
	if tmp, err := json.Marshal(strct.Run); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Defaults) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "run":
            if err := json.Unmarshal([]byte(v), &strct.Run); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Env) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal any additional Properties
    for k, v := range strct.AdditionalProperties {
		if comma {
			buf.WriteString(",")
		}
        buf.WriteString(fmt.Sprintf("\"%s\":", k))
		if tmp, err := json.Marshal(v); err != nil {
			return nil, err
		} else {
			buf.Write(tmp)
		}
        comma = true
	}

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Env) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        default:
            // an additional "interface{}" value
            var additionalValue interface{}
            if err := json.Unmarshal([]byte(v), &additionalValue); err != nil {
                return err // invalid additionalProperty
            }
            if strct.AdditionalProperties == nil {
                strct.AdditionalProperties = make(map[string]interface{}, 0)
            }
            strct.AdditionalProperties[k]= additionalValue
        }
    }
    return nil
}

func (strct *Environment) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // "Name" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "url" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"url\": ")
	if tmp, err := json.Marshal(strct.Url); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Environment) UnmarshalJSON(b []byte) error {
    nameReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
            nameReceived = true
        case "url":
            if err := json.Unmarshal([]byte(v), &strct.Url); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if name (a required property) was received
    if !nameReceived {
        return errors.New("\"name\" is required but was not present")
    }
    return nil
}

func (strct *Jobs) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Jobs) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, _ := range jsonMap {
        switch k {
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}

func (strct *Root) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "concurrency" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"concurrency\": ")
	if tmp, err := json.Marshal(strct.Concurrency); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "defaults" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"defaults\": ")
	if tmp, err := json.Marshal(strct.Defaults); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "env" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"env\": ")
	if tmp, err := json.Marshal(strct.Env); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "Jobs" field is required
    if strct.Jobs == nil {
        return nil, errors.New("jobs is a required field")
    }
    // Marshal the "jobs" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"jobs\": ")
	if tmp, err := json.Marshal(strct.Jobs); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "name" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"name\": ")
	if tmp, err := json.Marshal(strct.Name); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // "On" field is required
    // only required object types supported for marshal checking (for now)
    // Marshal the "on" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"on\": ")
	if tmp, err := json.Marshal(strct.On); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "permissions" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"permissions\": ")
	if tmp, err := json.Marshal(strct.Permissions); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Root) UnmarshalJSON(b []byte) error {
    jobsReceived := false
    onReceived := false
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "concurrency":
            if err := json.Unmarshal([]byte(v), &strct.Concurrency); err != nil {
                return err
             }
        case "defaults":
            if err := json.Unmarshal([]byte(v), &strct.Defaults); err != nil {
                return err
             }
        case "env":
            if err := json.Unmarshal([]byte(v), &strct.Env); err != nil {
                return err
             }
        case "jobs":
            if err := json.Unmarshal([]byte(v), &strct.Jobs); err != nil {
                return err
             }
            jobsReceived = true
        case "name":
            if err := json.Unmarshal([]byte(v), &strct.Name); err != nil {
                return err
             }
        case "on":
            if err := json.Unmarshal([]byte(v), &strct.On); err != nil {
                return err
             }
            onReceived = true
        case "permissions":
            if err := json.Unmarshal([]byte(v), &strct.Permissions); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    // check if jobs (a required property) was received
    if !jobsReceived {
        return errors.New("\"jobs\" is required but was not present")
    }
    // check if on (a required property) was received
    if !onReceived {
        return errors.New("\"on\" is required but was not present")
    }
    return nil
}

func (strct *Run) MarshalJSON() ([]byte, error) {
	buf := bytes.NewBuffer(make([]byte, 0))
	buf.WriteString("{")
    comma := false
    // Marshal the "shell" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"shell\": ")
	if tmp, err := json.Marshal(strct.Shell); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true
    // Marshal the "working-directory" field
    if comma { 
        buf.WriteString(",") 
    }
    buf.WriteString("\"working-directory\": ")
	if tmp, err := json.Marshal(strct.WorkingDirectory); err != nil {
		return nil, err
 	} else {
 		buf.Write(tmp)
	}
	comma = true

	buf.WriteString("}")
	rv := buf.Bytes()
	return rv, nil
}

func (strct *Run) UnmarshalJSON(b []byte) error {
    var jsonMap map[string]json.RawMessage
    if err := json.Unmarshal(b, &jsonMap); err != nil {
        return err
    }
    // parse all the defined properties
    for k, v := range jsonMap {
        switch k {
        case "shell":
            if err := json.Unmarshal([]byte(v), &strct.Shell); err != nil {
                return err
             }
        case "working-directory":
            if err := json.Unmarshal([]byte(v), &strct.WorkingDirectory); err != nil {
                return err
             }
        default:
            return fmt.Errorf("additional property not allowed: \"" + k + "\"")
        }
    }
    return nil
}
