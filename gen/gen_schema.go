// Code generated by schema-generate. DO NOT EDIT.
package gen
import (
	"fmt"
	"gopkg.in/yaml.v3"
)

// Root 
type Root struct {
	Architecture *Root_Definitions_Architecture `yaml:"architecture,omitempty"`

  // When using the push and pull_request events, you can configure a workflow to run on specific branches or tags. If you only define only tags or only branches, the workflow won't run for events affecting the undefined Git ref.
  // The branches, branches-ignore, tags, and tags-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one branch or tag name. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet.
  // The patterns defined in branches and tags are evaluated against the Git ref's name. For example, defining the pattern mona/octocat in branches will match the refs/heads/mona/octocat Git ref. The pattern releases/** will match the refs/heads/releases/10 Git ref.
  // You can use two types of filters to prevent a workflow from running on pushes and pull requests to tags and branches:
  // - branches or branches-ignore - You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the branches filter when you need to filter branches for positive matches and exclude branches. Use the branches-ignore filter when you only need to exclude branch names.
  // - tags or tags-ignore - You cannot use both the tags and tags-ignore filters for the same event in a workflow. Use the tags filter when you need to filter tags for positive matches and exclude tags. Use the tags-ignore filter when you only need to exclude tag names.
  // You can exclude tags and branches using the ! character. The order that you define patterns matters.
  // - A matching negative pattern (prefixed with !) after a positive match will exclude the Git ref.
  // - A matching positive pattern after a negative match will include the Git ref again.
	Branch *Root_Definitions_Branch `yaml:"branch,omitempty"`
	Configuration *Root_Definitions_Configuration `yaml:"configuration,omitempty"`
	Container *Root_Definitions_Container `yaml:"container,omitempty"`

  // The environment that the job references
	Environment *Root_Definitions_Environment `yaml:"environment,omitempty"`
	Event *Root_Definitions_Event `yaml:"event,omitempty"`
	EventObject *Root_Definitions_EventObject `yaml:"eventObject,omitempty"`
	ExpressionSyntax *Root_Definitions_ExpressionSyntax `yaml:"expressionSyntax,omitempty"`
	Globs *Root_Definitions_Globs `yaml:"globs,omitempty"`
	Machine *Root_Definitions_Machine `yaml:"machine,omitempty"`

  // When using the push and pull_request events, you can configure a workflow to run when at least one file does not match paths-ignore or at least one modified file matches the configured paths. Path filters are not evaluated for pushes to tags.
  // The paths-ignore and paths keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet.
  // You can exclude paths using two types of filters. You cannot use both of these filters for the same event in a workflow.
  // - paths-ignore - Use the paths-ignore filter when you only need to exclude path names.
  // - paths - Use the paths filter when you need to filter paths for positive matches and exclude paths.
	Path *Root_Definitions_Path `yaml:"path,omitempty"`
	Permissions_Event *Root_Definitions_Permissions_Event `yaml:"permissions-event,omitempty"`
	Permissions_Level *Root_Definitions_Permissions_Level `yaml:"permissions-level,omitempty"`
	Ref *Root_Definitions_Ref `yaml:"ref,omitempty"`

  // You can override the default shell settings in the runner's operating system using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options.
	Shell *Root_Definitions_Shell `yaml:"shell,omitempty"`

  // Selects the types of activity that will trigger a workflow run. Most GitHub events are triggered by more than one type of activity. For example, the event for the release resource is triggered when a release is published, unpublished, created, edited, deleted, or prereleased. The types keyword enables you to narrow down activity that causes the workflow to run. When only one activity type triggers a webhook event, the types keyword is unnecessary.
  // You can use an array of event types. For more information about each event and their activity types, see https://help.github.com/en/articles/events-that-trigger-workflows#webhook-events.
	Types *Root_Definitions_Types `yaml:"types,omitempty"`

  // Using the working-directory keyword, you can specify the working directory of where to run the command.
	Working_Directory *Root_Definitions_Working_Directory `yaml:"working-directory,omitempty"`

  // Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the secrets context. 
  // You can also specify concurrency at the workflow level. 
  // When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
	Concurrency *Root_Properties_Concurrency `yaml:"concurrency,omitempty"`

  // A map of default settings that will apply to all jobs in the workflow.
	Defaults *Root_Properties_Defaults `yaml:"defaults,omitempty"`

  // A map of environment variables that are available to all jobs and steps in the workflow.
	Env *Root_Properties_Env `yaml:"env,omitempty"`

  // A workflow run is made up of one or more jobs. Jobs run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.
  // Each job runs in a fresh instance of the virtual environment specified by runs-on.
  // You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#usage-limits.
	Jobs *Root_Properties_Jobs `yaml:"jobs"`

  // The name of your workflow. GitHub displays the names of your workflows on your repository's actions page. If you omit this field, GitHub sets the name to the workflow's filename.
	Name *Root_Properties_Name `yaml:"name,omitempty"`

  // The name of the GitHub event that triggers the workflow. You can provide a single event string, array of events, array of event types, or an event configuration map that schedules a workflow or restricts the execution of a workflow to specific files, tags, or branch changes. For a list of available events, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows.
	On *Root_Properties_On `yaml:"on"`
	Permissions *Root_Properties_Permissions `yaml:"permissions,omitempty"`
	Raw *yaml.Node
}

func (node *Root) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "architecture":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Architecture = new(Root_Definitions_Architecture)
				err := nodeValue.Decode(node.Architecture)
				if err != nil {
					return err
				}
			
			case "branch":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Branch = new(Root_Definitions_Branch)
				err := nodeValue.Decode(node.Branch)
				if err != nil {
					return err
				}
			
			case "configuration":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Configuration = new(Root_Definitions_Configuration)
				err := nodeValue.Decode(node.Configuration)
				if err != nil {
					return err
				}
			
			case "container":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Container = new(Root_Definitions_Container)
				err := nodeValue.Decode(node.Container)
				if err != nil {
					return err
				}
			
			case "environment":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Environment = new(Root_Definitions_Environment)
				err := nodeValue.Decode(node.Environment)
				if err != nil {
					return err
				}
			
			case "event":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Event = new(Root_Definitions_Event)
				err := nodeValue.Decode(node.Event)
				if err != nil {
					return err
				}
			
			case "eventobject":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.EventObject = new(Root_Definitions_EventObject)
				err := nodeValue.Decode(node.EventObject)
				if err != nil {
					return err
				}
			
			case "expressionsyntax":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.ExpressionSyntax = new(Root_Definitions_ExpressionSyntax)
				err := nodeValue.Decode(node.ExpressionSyntax)
				if err != nil {
					return err
				}
			
			case "globs":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Globs = new(Root_Definitions_Globs)
				err := nodeValue.Decode(node.Globs)
				if err != nil {
					return err
				}
			
			case "machine":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Machine = new(Root_Definitions_Machine)
				err := nodeValue.Decode(node.Machine)
				if err != nil {
					return err
				}
			
			case "path":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Path = new(Root_Definitions_Path)
				err := nodeValue.Decode(node.Path)
				if err != nil {
					return err
				}
			
			case "permissions_event":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Permissions_Event = new(Root_Definitions_Permissions_Event)
				err := nodeValue.Decode(node.Permissions_Event)
				if err != nil {
					return err
				}
			
			case "permissions_level":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Permissions_Level = new(Root_Definitions_Permissions_Level)
				err := nodeValue.Decode(node.Permissions_Level)
				if err != nil {
					return err
				}
			
			case "ref":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Ref = new(Root_Definitions_Ref)
				err := nodeValue.Decode(node.Ref)
				if err != nil {
					return err
				}
			
			case "shell":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Shell = new(Root_Definitions_Shell)
				err := nodeValue.Decode(node.Shell)
				if err != nil {
					return err
				}
			
			case "types":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Types = new(Root_Definitions_Types)
				err := nodeValue.Decode(node.Types)
				if err != nil {
					return err
				}
			
			case "working_directory":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Working_Directory = new(Root_Definitions_Working_Directory)
				err := nodeValue.Decode(node.Working_Directory)
				if err != nil {
					return err
				}
			
			case "concurrency":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Concurrency = new(Root_Properties_Concurrency)
				err := nodeValue.Decode(node.Concurrency)
				if err != nil {
					return err
				}
			
			case "defaults":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Defaults = new(Root_Properties_Defaults)
				err := nodeValue.Decode(node.Defaults)
				if err != nil {
					return err
				}
			
			case "env":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Env = new(Root_Properties_Env)
				err := nodeValue.Decode(node.Env)
				if err != nil {
					return err
				}
			
			case "jobs":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Jobs = new(Root_Properties_Jobs)
				err := nodeValue.Decode(node.Jobs)
				if err != nil {
					return err
				}
			
			case "name":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Name = new(Root_Properties_Name)
				err := nodeValue.Decode(node.Name)
				if err != nil {
					return err
				}
			
			case "on":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.On = new(Root_Properties_On)
				err := nodeValue.Decode(node.On)
				if err != nil {
					return err
				}
			
			case "permissions":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Permissions = new(Root_Properties_Permissions)
				err := nodeValue.Decode(node.Permissions)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Architecture 
type Root_Definitions_Architecture struct {
	Value *Root_Definitions_Architecture `yaml:"architecture,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Architecture) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Architecture)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Branch When using the push and pull_request events, you can configure a workflow to run on specific branches or tags. If you only define only tags or only branches, the workflow won't run for events affecting the undefined Git ref.
// The branches, branches-ignore, tags, and tags-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one branch or tag name. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet.
// The patterns defined in branches and tags are evaluated against the Git ref's name. For example, defining the pattern mona/octocat in branches will match the refs/heads/mona/octocat Git ref. The pattern releases/** will match the refs/heads/releases/10 Git ref.
// You can use two types of filters to prevent a workflow from running on pushes and pull requests to tags and branches:
// - branches or branches-ignore - You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the branches filter when you need to filter branches for positive matches and exclude branches. Use the branches-ignore filter when you only need to exclude branch names.
// - tags or tags-ignore - You cannot use both the tags and tags-ignore filters for the same event in a workflow. Use the tags filter when you need to filter tags for positive matches and exclude tags. Use the tags-ignore filter when you only need to exclude tag names.
// You can exclude tags and branches using the ! character. The order that you define patterns matters.
// - A matching negative pattern (prefixed with !) after a positive match will exclude the Git ref.
// - A matching positive pattern after a negative match will include the Git ref again.
type Root_Definitions_Branch struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Branch) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Concurrency 
type Root_Definitions_Concurrency struct {

  // To cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
	Cancel_In_Progress *Root_Definitions_Concurrency_Properties_Cancel_In_Progress `yaml:"cancel-in-progress,omitempty"`

  // When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled.
	Group *Root_Definitions_Concurrency_Properties_Group `yaml:"group"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Concurrency) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "cancel_in_progress":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Cancel_In_Progress = new(Root_Definitions_Concurrency_Properties_Cancel_In_Progress)
				err := nodeValue.Decode(node.Cancel_In_Progress)
				if err != nil {
					return err
				}
			
			case "group":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Group = new(Root_Definitions_Concurrency_Properties_Group)
				err := nodeValue.Decode(node.Group)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Concurrency_Properties_Cancel_In_Progress To cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
type Root_Definitions_Concurrency_Properties_Cancel_In_Progress struct {

  // To cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
	Value *Root_Definitions_Concurrency_Properties_Cancel_In_Progress `yaml:"progress,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Concurrency_Properties_Cancel_In_Progress) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Concurrency_Properties_Cancel_In_Progress)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Concurrency_Properties_Group When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled.
type Root_Definitions_Concurrency_Properties_Group struct {

  // When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled.
	Value *Root_Definitions_Concurrency_Properties_Group `yaml:"group,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Concurrency_Properties_Group) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Concurrency_Properties_Group)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Configuration 
type Root_Definitions_Configuration struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Configuration) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Container 
type Root_Definitions_Container struct {

  // If the image's container registry requires authentication to pull the image, you can use credentials to set a map of the username and password. The credentials are the same values that you would provide to the `docker login` command.
	Credentials *Root_Definitions_Container_Properties_Credentials `yaml:"credentials,omitempty"`

  // Sets an array of environment variables in the container.
	Env *Root_Definitions_Container_Properties_Env `yaml:"env,omitempty"`

  // The Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.
	Image *Root_Definitions_Container_Properties_Image `yaml:"image"`

  // Additional Docker container resource options. For a list of options, see https://docs.docker.com/engine/reference/commandline/create/#options.
	Options *Root_Definitions_Container_Properties_Options `yaml:"options,omitempty"`

  // Sets an array of ports to expose on the container.
	Ports *Root_Definitions_Container_Properties_Ports `yaml:"ports,omitempty"`

  // Sets an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.
  // To specify a volume, you specify the source and destination path: <source>:<destinationPath>
  // The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.
	Volumes *Root_Definitions_Container_Properties_Volumes `yaml:"volumes,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Container) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "credentials":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Credentials = new(Root_Definitions_Container_Properties_Credentials)
				err := nodeValue.Decode(node.Credentials)
				if err != nil {
					return err
				}
			
			case "env":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Env = new(Root_Definitions_Container_Properties_Env)
				err := nodeValue.Decode(node.Env)
				if err != nil {
					return err
				}
			
			case "image":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Image = new(Root_Definitions_Container_Properties_Image)
				err := nodeValue.Decode(node.Image)
				if err != nil {
					return err
				}
			
			case "options":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Options = new(Root_Definitions_Container_Properties_Options)
				err := nodeValue.Decode(node.Options)
				if err != nil {
					return err
				}
			
			case "ports":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Ports = new(Root_Definitions_Container_Properties_Ports)
				err := nodeValue.Decode(node.Ports)
				if err != nil {
					return err
				}
			
			case "volumes":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Volumes = new(Root_Definitions_Container_Properties_Volumes)
				err := nodeValue.Decode(node.Volumes)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Container_Properties_Credentials If the image's container registry requires authentication to pull the image, you can use credentials to set a map of the username and password. The credentials are the same values that you would provide to the `docker login` command.
type Root_Definitions_Container_Properties_Credentials struct {
	Password *Root_Definitions_Container_Properties_Credentials_Properties_Password `yaml:"password,omitempty"`
	Username *Root_Definitions_Container_Properties_Credentials_Properties_Username `yaml:"username,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Container_Properties_Credentials) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "password":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Password = new(Root_Definitions_Container_Properties_Credentials_Properties_Password)
				err := nodeValue.Decode(node.Password)
				if err != nil {
					return err
				}
			
			case "username":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Username = new(Root_Definitions_Container_Properties_Credentials_Properties_Username)
				err := nodeValue.Decode(node.Username)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Container_Properties_Credentials_Properties_Password 
type Root_Definitions_Container_Properties_Credentials_Properties_Password struct {
	Value *Root_Definitions_Container_Properties_Credentials_Properties_Password `yaml:"password,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Container_Properties_Credentials_Properties_Password) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Container_Properties_Credentials_Properties_Password)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Container_Properties_Credentials_Properties_Username 
type Root_Definitions_Container_Properties_Credentials_Properties_Username struct {
	Value *Root_Definitions_Container_Properties_Credentials_Properties_Username `yaml:"username,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Container_Properties_Credentials_Properties_Username) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Container_Properties_Credentials_Properties_Username)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Container_Properties_Env Sets an array of environment variables in the container.
type Root_Definitions_Container_Properties_Env struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Container_Properties_Env) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Container_Properties_Image The Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.
type Root_Definitions_Container_Properties_Image struct {

  // The Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.
	Value *Root_Definitions_Container_Properties_Image `yaml:"image,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Container_Properties_Image) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Container_Properties_Image)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Container_Properties_Options Additional Docker container resource options. For a list of options, see https://docs.docker.com/engine/reference/commandline/create/#options.
type Root_Definitions_Container_Properties_Options struct {

  // Additional Docker container resource options. For a list of options, see https://docs.docker.com/engine/reference/commandline/create/#options.
	Value *Root_Definitions_Container_Properties_Options `yaml:"options,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Container_Properties_Options) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Container_Properties_Options)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Container_Properties_Ports Sets an array of ports to expose on the container.
type Root_Definitions_Container_Properties_Ports struct {

  // Sets an array of ports to expose on the container.
	Root_Definitions_Container_Properties_Ports *[]Root_Definitions_Container_Properties_Ports_Items_Root_Definitions_Container_Properties_Ports `yaml:"ports,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Container_Properties_Ports) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "root_definitions_container_properties_ports":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Root_Definitions_Container_Properties_Ports = new([]Root_Definitions_Container_Properties_Ports_Items_Root_Definitions_Container_Properties_Ports)
				err := nodeValue.Decode(node.Root_Definitions_Container_Properties_Ports)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Container_Properties_Ports_Items_Root_Definitions_Container_Properties_Ports 
type Root_Definitions_Container_Properties_Ports_Items_Root_Definitions_Container_Properties_Ports struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Container_Properties_Ports_Items_Root_Definitions_Container_Properties_Ports) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Container_Properties_Volumes Sets an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.
// To specify a volume, you specify the source and destination path: <source>:<destinationPath>
// The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.
type Root_Definitions_Container_Properties_Volumes struct {

  // Sets an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.
  // To specify a volume, you specify the source and destination path: <source>:<destinationPath>
  // The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.
	Root_Definitions_Container_Properties_Volumes *[]Root_Definitions_Container_Properties_Volumes_Items_Root_Definitions_Container_Properties_Volumes `yaml:"volumes,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Container_Properties_Volumes) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "root_definitions_container_properties_volumes":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Root_Definitions_Container_Properties_Volumes = new([]Root_Definitions_Container_Properties_Volumes_Items_Root_Definitions_Container_Properties_Volumes)
				err := nodeValue.Decode(node.Root_Definitions_Container_Properties_Volumes)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Container_Properties_Volumes_Items_Root_Definitions_Container_Properties_Volumes 
type Root_Definitions_Container_Properties_Volumes_Items_Root_Definitions_Container_Properties_Volumes struct {
	Value *Root_Definitions_Container_Properties_Volumes_Items_Root_Definitions_Container_Properties_Volumes `yaml:"volumes,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Container_Properties_Volumes_Items_Root_Definitions_Container_Properties_Volumes) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Container_Properties_Volumes_Items_Root_Definitions_Container_Properties_Volumes)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Defaults 
type Root_Definitions_Defaults struct {
	Run *Root_Definitions_Defaults_Properties_Run `yaml:"run,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Defaults) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "run":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Run = new(Root_Definitions_Defaults_Properties_Run)
				err := nodeValue.Decode(node.Run)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Defaults_Properties_Run 
type Root_Definitions_Defaults_Properties_Run struct {
	Shell *Root_Definitions_Defaults_Properties_Run_Properties_Shell `yaml:"shell,omitempty"`
	Working_Directory *Root_Definitions_Defaults_Properties_Run_Properties_Working_Directory `yaml:"working-directory,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Defaults_Properties_Run) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "shell":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Shell = new(Root_Definitions_Defaults_Properties_Run_Properties_Shell)
				err := nodeValue.Decode(node.Shell)
				if err != nil {
					return err
				}
			
			case "working_directory":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Working_Directory = new(Root_Definitions_Defaults_Properties_Run_Properties_Working_Directory)
				err := nodeValue.Decode(node.Working_Directory)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Defaults_Properties_Run_Properties_Shell 
type Root_Definitions_Defaults_Properties_Run_Properties_Shell struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Defaults_Properties_Run_Properties_Shell) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Defaults_Properties_Run_Properties_Working_Directory 
type Root_Definitions_Defaults_Properties_Run_Properties_Working_Directory struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Defaults_Properties_Run_Properties_Working_Directory) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Env 
type Root_Definitions_Env struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Env) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Environment The environment that the job references
type Root_Definitions_Environment struct {

  // The name of the environment configured in the repo.
	Name *Root_Definitions_Environment_Properties_Name `yaml:"name"`

  // A deployment URL
	Url *Root_Definitions_Environment_Properties_Url `yaml:"url,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Environment) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "name":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Name = new(Root_Definitions_Environment_Properties_Name)
				err := nodeValue.Decode(node.Name)
				if err != nil {
					return err
				}
			
			case "url":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Url = new(Root_Definitions_Environment_Properties_Url)
				err := nodeValue.Decode(node.Url)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Environment_Properties_Name The name of the environment configured in the repo.
type Root_Definitions_Environment_Properties_Name struct {

  // The name of the environment configured in the repo.
	Value *Root_Definitions_Environment_Properties_Name `yaml:"name,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Environment_Properties_Name) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Environment_Properties_Name)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Environment_Properties_Url A deployment URL
type Root_Definitions_Environment_Properties_Url struct {

  // A deployment URL
	Value *Root_Definitions_Environment_Properties_Url `yaml:"url,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Environment_Properties_Url) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Environment_Properties_Url)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Event 
type Root_Definitions_Event struct {
	Value *Root_Definitions_Event `yaml:"event,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Event) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Event)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_EventObject 
type Root_Definitions_EventObject struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_EventObject) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_ExpressionSyntax 
type Root_Definitions_ExpressionSyntax struct {
	Value *Root_Definitions_ExpressionSyntax `yaml:"expressionsyntax,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_ExpressionSyntax) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_ExpressionSyntax)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Globs 
type Root_Definitions_Globs struct {
	Root_Definitions_Globs *[]Root_Definitions_Globs_Items_Root_Definitions_Globs `yaml:"globs,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Globs) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "root_definitions_globs":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Root_Definitions_Globs = new([]Root_Definitions_Globs_Items_Root_Definitions_Globs)
				err := nodeValue.Decode(node.Root_Definitions_Globs)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Globs_Items_Root_Definitions_Globs 
type Root_Definitions_Globs_Items_Root_Definitions_Globs struct {
	Value *Root_Definitions_Globs_Items_Root_Definitions_Globs `yaml:"globs,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Globs_Items_Root_Definitions_Globs) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Globs_Items_Root_Definitions_Globs)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Machine 
type Root_Definitions_Machine struct {
	Value *Root_Definitions_Machine `yaml:"machine,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Machine) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Machine)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Name 
type Root_Definitions_Name struct {
	Value *Root_Definitions_Name `yaml:"name,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Name) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Name)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Path When using the push and pull_request events, you can configure a workflow to run when at least one file does not match paths-ignore or at least one modified file matches the configured paths. Path filters are not evaluated for pushes to tags.
// The paths-ignore and paths keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet.
// You can exclude paths using two types of filters. You cannot use both of these filters for the same event in a workflow.
// - paths-ignore - Use the paths-ignore filter when you only need to exclude path names.
// - paths - Use the paths filter when you need to filter paths for positive matches and exclude paths.
type Root_Definitions_Path struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Path) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions You can modify the default permissions granted to the GITHUB_TOKEN, adding or removing access as required, so that you only allow the minimum required access.
type Root_Definitions_Permissions struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event 
type Root_Definitions_Permissions_Event struct {
	Actions *Root_Definitions_Permissions_Event_Properties_Actions `yaml:"actions,omitempty"`
	Checks *Root_Definitions_Permissions_Event_Properties_Checks `yaml:"checks,omitempty"`
	Contents *Root_Definitions_Permissions_Event_Properties_Contents `yaml:"contents,omitempty"`
	Deployments *Root_Definitions_Permissions_Event_Properties_Deployments `yaml:"deployments,omitempty"`
	Issues *Root_Definitions_Permissions_Event_Properties_Issues `yaml:"issues,omitempty"`
	Packages *Root_Definitions_Permissions_Event_Properties_Packages `yaml:"packages,omitempty"`
	Pull_Requests *Root_Definitions_Permissions_Event_Properties_Pull_Requests `yaml:"pull-requests,omitempty"`
	Repository_Projects *Root_Definitions_Permissions_Event_Properties_Repository_Projects `yaml:"repository-projects,omitempty"`
	Security_Events *Root_Definitions_Permissions_Event_Properties_Security_Events `yaml:"security-events,omitempty"`
	Statuses *Root_Definitions_Permissions_Event_Properties_Statuses `yaml:"statuses,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "actions":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Actions = new(Root_Definitions_Permissions_Event_Properties_Actions)
				err := nodeValue.Decode(node.Actions)
				if err != nil {
					return err
				}
			
			case "checks":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Checks = new(Root_Definitions_Permissions_Event_Properties_Checks)
				err := nodeValue.Decode(node.Checks)
				if err != nil {
					return err
				}
			
			case "contents":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Contents = new(Root_Definitions_Permissions_Event_Properties_Contents)
				err := nodeValue.Decode(node.Contents)
				if err != nil {
					return err
				}
			
			case "deployments":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Deployments = new(Root_Definitions_Permissions_Event_Properties_Deployments)
				err := nodeValue.Decode(node.Deployments)
				if err != nil {
					return err
				}
			
			case "issues":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Issues = new(Root_Definitions_Permissions_Event_Properties_Issues)
				err := nodeValue.Decode(node.Issues)
				if err != nil {
					return err
				}
			
			case "packages":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Packages = new(Root_Definitions_Permissions_Event_Properties_Packages)
				err := nodeValue.Decode(node.Packages)
				if err != nil {
					return err
				}
			
			case "pull_requests":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Pull_Requests = new(Root_Definitions_Permissions_Event_Properties_Pull_Requests)
				err := nodeValue.Decode(node.Pull_Requests)
				if err != nil {
					return err
				}
			
			case "repository_projects":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Repository_Projects = new(Root_Definitions_Permissions_Event_Properties_Repository_Projects)
				err := nodeValue.Decode(node.Repository_Projects)
				if err != nil {
					return err
				}
			
			case "security_events":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Security_Events = new(Root_Definitions_Permissions_Event_Properties_Security_Events)
				err := nodeValue.Decode(node.Security_Events)
				if err != nil {
					return err
				}
			
			case "statuses":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Statuses = new(Root_Definitions_Permissions_Event_Properties_Statuses)
				err := nodeValue.Decode(node.Statuses)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event_Properties_Actions 
type Root_Definitions_Permissions_Event_Properties_Actions struct {
	Ref *Root_Definitions_Permissions_Level `yaml:"permissions_level,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event_Properties_Actions) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "ref":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Ref = new(Root_Definitions_Permissions_Level)
				err := nodeValue.Decode(node.Ref)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event_Properties_Checks 
type Root_Definitions_Permissions_Event_Properties_Checks struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event_Properties_Checks) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event_Properties_Contents 
type Root_Definitions_Permissions_Event_Properties_Contents struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event_Properties_Contents) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event_Properties_Deployments 
type Root_Definitions_Permissions_Event_Properties_Deployments struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event_Properties_Deployments) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event_Properties_Issues 
type Root_Definitions_Permissions_Event_Properties_Issues struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event_Properties_Issues) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event_Properties_Packages 
type Root_Definitions_Permissions_Event_Properties_Packages struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event_Properties_Packages) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event_Properties_Pull_Requests 
type Root_Definitions_Permissions_Event_Properties_Pull_Requests struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event_Properties_Pull_Requests) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event_Properties_Repository_Projects 
type Root_Definitions_Permissions_Event_Properties_Repository_Projects struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event_Properties_Repository_Projects) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event_Properties_Security_Events 
type Root_Definitions_Permissions_Event_Properties_Security_Events struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event_Properties_Security_Events) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Event_Properties_Statuses 
type Root_Definitions_Permissions_Event_Properties_Statuses struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Event_Properties_Statuses) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Permissions_Level 
type Root_Definitions_Permissions_Level struct {
	Value *Root_Definitions_Permissions_Level `yaml:"level,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Permissions_Level) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Permissions_Level)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Ref 
type Root_Definitions_Ref struct {
	Branches *Root_Definitions_Ref_Properties_Branches `yaml:"branches,omitempty"`
	Branches_Ignore *Root_Definitions_Ref_Properties_Branches_Ignore `yaml:"branches-ignore,omitempty"`
	Paths *Root_Definitions_Ref_Properties_Paths `yaml:"paths,omitempty"`
	Paths_Ignore *Root_Definitions_Ref_Properties_Paths_Ignore `yaml:"paths-ignore,omitempty"`
	Tags *Root_Definitions_Ref_Properties_Tags `yaml:"tags,omitempty"`
	Tags_Ignore *Root_Definitions_Ref_Properties_Tags_Ignore `yaml:"tags-ignore,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Ref) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "branches":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Branches = new(Root_Definitions_Ref_Properties_Branches)
				err := nodeValue.Decode(node.Branches)
				if err != nil {
					return err
				}
			
			case "branches_ignore":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Branches_Ignore = new(Root_Definitions_Ref_Properties_Branches_Ignore)
				err := nodeValue.Decode(node.Branches_Ignore)
				if err != nil {
					return err
				}
			
			case "paths":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Paths = new(Root_Definitions_Ref_Properties_Paths)
				err := nodeValue.Decode(node.Paths)
				if err != nil {
					return err
				}
			
			case "paths_ignore":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Paths_Ignore = new(Root_Definitions_Ref_Properties_Paths_Ignore)
				err := nodeValue.Decode(node.Paths_Ignore)
				if err != nil {
					return err
				}
			
			case "tags":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Tags = new(Root_Definitions_Ref_Properties_Tags)
				err := nodeValue.Decode(node.Tags)
				if err != nil {
					return err
				}
			
			case "tags_ignore":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Tags_Ignore = new(Root_Definitions_Ref_Properties_Tags_Ignore)
				err := nodeValue.Decode(node.Tags_Ignore)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Ref_Properties_Branches 
type Root_Definitions_Ref_Properties_Branches struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Ref_Properties_Branches) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Ref_Properties_Branches_Ignore 
type Root_Definitions_Ref_Properties_Branches_Ignore struct {

  // When using the push and pull_request events, you can configure a workflow to run on specific branches or tags. If you only define only tags or only branches, the workflow won't run for events affecting the undefined Git ref.
  // The branches, branches-ignore, tags, and tags-ignore keywords accept glob patterns that use the * and ** wildcard characters to match more than one branch or tag name. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet.
  // The patterns defined in branches and tags are evaluated against the Git ref's name. For example, defining the pattern mona/octocat in branches will match the refs/heads/mona/octocat Git ref. The pattern releases/** will match the refs/heads/releases/10 Git ref.
  // You can use two types of filters to prevent a workflow from running on pushes and pull requests to tags and branches:
  // - branches or branches-ignore - You cannot use both the branches and branches-ignore filters for the same event in a workflow. Use the branches filter when you need to filter branches for positive matches and exclude branches. Use the branches-ignore filter when you only need to exclude branch names.
  // - tags or tags-ignore - You cannot use both the tags and tags-ignore filters for the same event in a workflow. Use the tags filter when you need to filter tags for positive matches and exclude tags. Use the tags-ignore filter when you only need to exclude tag names.
  // You can exclude tags and branches using the ! character. The order that you define patterns matters.
  // - A matching negative pattern (prefixed with !) after a positive match will exclude the Git ref.
  // - A matching positive pattern after a negative match will include the Git ref again.
	Ref *Root_Definitions_Branch `yaml:"branch,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Ref_Properties_Branches_Ignore) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "ref":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Ref = new(Root_Definitions_Branch)
				err := nodeValue.Decode(node.Ref)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Ref_Properties_Paths 
type Root_Definitions_Ref_Properties_Paths struct {

  // When using the push and pull_request events, you can configure a workflow to run when at least one file does not match paths-ignore or at least one modified file matches the configured paths. Path filters are not evaluated for pushes to tags.
  // The paths-ignore and paths keywords accept glob patterns that use the * and ** wildcard characters to match more than one path name. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#filter-pattern-cheat-sheet.
  // You can exclude paths using two types of filters. You cannot use both of these filters for the same event in a workflow.
  // - paths-ignore - Use the paths-ignore filter when you only need to exclude path names.
  // - paths - Use the paths filter when you need to filter paths for positive matches and exclude paths.
	Ref *Root_Definitions_Path `yaml:"path,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Ref_Properties_Paths) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "ref":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Ref = new(Root_Definitions_Path)
				err := nodeValue.Decode(node.Ref)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Ref_Properties_Paths_Ignore 
type Root_Definitions_Ref_Properties_Paths_Ignore struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Ref_Properties_Paths_Ignore) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Ref_Properties_Tags 
type Root_Definitions_Ref_Properties_Tags struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Ref_Properties_Tags) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Ref_Properties_Tags_Ignore 
type Root_Definitions_Ref_Properties_Tags_Ignore struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Ref_Properties_Tags_Ignore) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Shell You can override the default shell settings in the runner's operating system using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options.
type Root_Definitions_Shell struct {

  // You can override the default shell settings in the runner's operating system using the shell keyword. You can use built-in shell keywords, or you can define a custom set of shell options.
	Value *Root_Definitions_Shell `yaml:"shell,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Shell) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Shell)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Definitions_Types Selects the types of activity that will trigger a workflow run. Most GitHub events are triggered by more than one type of activity. For example, the event for the release resource is triggered when a release is published, unpublished, created, edited, deleted, or prereleased. The types keyword enables you to narrow down activity that causes the workflow to run. When only one activity type triggers a webhook event, the types keyword is unnecessary.
// You can use an array of event types. For more information about each event and their activity types, see https://help.github.com/en/articles/events-that-trigger-workflows#webhook-events.
type Root_Definitions_Types struct {
	Raw *yaml.Node
}

func (node *Root_Definitions_Types) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Definitions_Working_Directory Using the working-directory keyword, you can specify the working directory of where to run the command.
type Root_Definitions_Working_Directory struct {

  // Using the working-directory keyword, you can specify the working directory of where to run the command.
	Value *Root_Definitions_Working_Directory `yaml:"directory,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Definitions_Working_Directory) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Definitions_Working_Directory)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Properties_Concurrency Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the secrets context. 
// You can also specify concurrency at the workflow level. 
// When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
type Root_Properties_Concurrency struct {
	Raw *yaml.Node
}

func (node *Root_Properties_Concurrency) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Properties_Defaults A map of default settings that will apply to all jobs in the workflow.
type Root_Properties_Defaults struct {
	Raw *yaml.Node
}

func (node *Root_Properties_Defaults) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Properties_Env A map of environment variables that are available to all jobs and steps in the workflow.
type Root_Properties_Env struct {
	Raw *yaml.Node
}

func (node *Root_Properties_Env) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Properties_Jobs A workflow run is made up of one or more jobs. Jobs run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.
// Each job runs in a fresh instance of the virtual environment specified by runs-on.
// You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#usage-limits.
type Root_Properties_Jobs struct {
	Raw *yaml.Node
}

func (node *Root_Properties_Jobs) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Properties_Name The name of your workflow. GitHub displays the names of your workflows on your repository's actions page. If you omit this field, GitHub sets the name to the workflow's filename.
type Root_Properties_Name struct {

  // The name of your workflow. GitHub displays the names of your workflows on your repository's actions page. If you omit this field, GitHub sets the name to the workflow's filename.
	Value *Root_Properties_Name `yaml:"name,omitempty"`
	Raw *yaml.Node
}

func (node *Root_Properties_Name) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
			case "value":
				i++
				if i >= len(value.Content) {
					return fmt.Errorf("value.Content mismatch")
				}
				nodeValue := value.Content[i]
				node.Value = new(Root_Properties_Name)
				err := nodeValue.Decode(node.Value)
				if err != nil {
					return err
				}
			
		}
	}
	return nil
}

// Root_Properties_On The name of the GitHub event that triggers the workflow. You can provide a single event string, array of events, array of event types, or an event configuration map that schedules a workflow or restricts the execution of a workflow to specific files, tags, or branch changes. For a list of available events, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows.
type Root_Properties_On struct {
	Raw *yaml.Node
}

func (node *Root_Properties_On) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}

// Root_Properties_Permissions 
type Root_Properties_Permissions struct {
	Raw *yaml.Node
}

func (node *Root_Properties_Permissions) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	for i := 0; i < len(value.Content); i++ {
		nodeName := value.Content[i]
		switch nodeName.Value {
			
		}
	}
	return nil
}
