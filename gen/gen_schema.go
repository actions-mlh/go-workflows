// Code generated by schema-generate. DO NOT EDIT.
package gen_schema
import (
	"gopkg.in/yaml.v3"
)

// Concurrency 
type Concurrency struct {

  // To cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
  CancelInProgress CancelInProgressRaw `yaml:"cancel-in-progress,omitempty"`

  // When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled.
  Group GroupRaw `yaml:"group"`
}

// Container 
type Container struct {

  // If the image's container registry requires authentication to pull the image, you can use credentials to set a map of the username and password. The credentials are the same values that you would provide to the `docker login` command.
  Credentials CredentialsRaw `yaml:"credentials,omitempty"`

  // Sets an array of environment variables in the container.
  Env EnvRaw `yaml:"env,omitempty"`

  // The Docker image to use as the container to run the action. The value can be the Docker Hub image name or a registry name.
  Image ImageRaw `yaml:"image"`

  // Additional Docker container resource options. For a list of options, see https://docs.docker.com/engine/reference/commandline/create/#options.
  Options OptionsRaw `yaml:"options,omitempty"`

  // Sets an array of ports to expose on the container.
  Ports PortsRaw `yaml:"ports,omitempty"`

  // Sets an array of volumes for the container to use. You can use volumes to share data between services or other steps in a job. You can specify named Docker volumes, anonymous Docker volumes, or bind mounts on the host.
  // To specify a volume, you specify the source and destination path: <source>:<destinationPath>
  // The <source> is a volume name or an absolute path on the host machine, and <destinationPath> is an absolute path in the container.
  Volumes VolumesRaw `yaml:"volumes,omitempty"`
}

// Credentials If the image's container registry requires authentication to pull the image, you can use credentials to set a map of the username and password. The credentials are the same values that you would provide to the `docker login` command.
type Credentials struct {
  Password PasswordRaw `yaml:"password,omitempty"`
  Username UsernameRaw `yaml:"username,omitempty"`
}

// Defaults 
type Defaults struct {
  Run RunRaw `yaml:"run,omitempty"`
}

// Env 
type Env struct {
  AdditionalProperties AdditionalPropertiesRaw `yaml:"-,omitempty"`
}

// Environment The environment that the job references
type Environment struct {

  // The name of the environment configured in the repo.
  Name NameRaw `yaml:"name"`

  // A deployment URL
  Url UrlRaw `yaml:"url,omitempty"`
}

// Jobs A workflow run is made up of one or more jobs. Jobs run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.
// Each job runs in a fresh instance of the virtual environment specified by runs-on.
// You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#usage-limits.
type Jobs struct {
}

// PermissionsEvent 
type PermissionsEvent struct {
  Actions ActionsRaw `yaml:"actions,omitempty"`
  Checks ChecksRaw `yaml:"checks,omitempty"`
  Contents ContentsRaw `yaml:"contents,omitempty"`
  Deployments DeploymentsRaw `yaml:"deployments,omitempty"`
  Issues IssuesRaw `yaml:"issues,omitempty"`
  Packages PackagesRaw `yaml:"packages,omitempty"`
  PullRequests PullRequestsRaw `yaml:"pull-requests,omitempty"`
  RepositoryProjects RepositoryProjectsRaw `yaml:"repository-projects,omitempty"`
  SecurityEvents SecurityEventsRaw `yaml:"security-events,omitempty"`
  Statuses StatusesRaw `yaml:"statuses,omitempty"`
}

// Ref 
type Ref struct {
  Branches BranchesRaw `yaml:"branches,omitempty"`
  BranchesIgnore BranchesIgnoreRaw `yaml:"branches-ignore,omitempty"`
  Paths PathsRaw `yaml:"paths,omitempty"`
  PathsIgnore PathsIgnoreRaw `yaml:"paths-ignore,omitempty"`
  Tags TagsRaw `yaml:"tags,omitempty"`
  TagsIgnore TagsIgnoreRaw `yaml:"tags-ignore,omitempty"`
}

// Run 
type Run struct {
  Shell ShellRaw `yaml:"shell,omitempty"`
  WorkingDirectory WorkingDirectoryRaw `yaml:"working-directory,omitempty"`
}

// WorkflowRoot 
type WorkflowRoot struct {

  // Concurrency ensures that only a single job or workflow using the same concurrency group will run at a time. A concurrency group can be any string or expression. The expression can use any context except for the secrets context. 
  // You can also specify concurrency at the workflow level. 
  // When a concurrent job or workflow is queued, if another job or workflow using the same concurrency group in the repository is in progress, the queued job or workflow will be pending. Any previously pending job or workflow in the concurrency group will be canceled. To also cancel any currently running job or workflow in the same concurrency group, specify cancel-in-progress: true.
  Concurrency ConcurrencyRaw `yaml:"concurrency,omitempty"`

  // A map of default settings that will apply to all jobs in the workflow.
  Defaults DefaultsRaw `yaml:"defaults,omitempty"`

  // A map of environment variables that are available to all jobs and steps in the workflow.
  Env EnvRaw `yaml:"env,omitempty"`

  // A workflow run is made up of one or more jobs. Jobs run in parallel by default. To run jobs sequentially, you can define dependencies on other jobs using the jobs.<job_id>.needs keyword.
  // Each job runs in a fresh instance of the virtual environment specified by runs-on.
  // You can run an unlimited number of jobs as long as you are within the workflow usage limits. For more information, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#usage-limits.
  Jobs JobsRaw `yaml:"jobs"`

  // The name of your workflow. GitHub displays the names of your workflows on your repository's actions page. If you omit this field, GitHub sets the name to the workflow's filename.
  Name NameRaw `yaml:"name,omitempty"`

  // The name of the GitHub event that triggers the workflow. You can provide a single event string, array of events, array of event types, or an event configuration map that schedules a workflow or restricts the execution of a workflow to specific files, tags, or branch changes. For a list of available events, see https://help.github.com/en/github/automating-your-workflow-with-github-actions/events-that-trigger-workflows.
  On OnRaw `yaml:"on"`
  Permissions PermissionsRaw `yaml:"permissions,omitempty"`
}

type CancelInProgressRaw struct {
	Raw *yaml.Node
	Value bool
}


func (node *CancelInProgressRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type GroupRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *GroupRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type CredentialsRaw struct {
	Raw *yaml.Node
	Value *Credentials
}


func (node *CredentialsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type EnvRaw struct {
	Raw *yaml.Node
	Value *Env
}


func (node *EnvRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type ImageRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *ImageRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type OptionsRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *OptionsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type PortsRaw struct {
	Raw *yaml.Node
	Value []interface{}
}


func (node *PortsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type VolumesRaw struct {
	Raw *yaml.Node
	Value []string
}


func (node *VolumesRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type PasswordRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *PasswordRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type UsernameRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *UsernameRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type RunRaw struct {
	Raw *yaml.Node
	Value *Run
}


func (node *RunRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type AdditionalPropertiesRaw struct {
	Raw *yaml.Node
	Value map[string]interface{}
}


func (node *AdditionalPropertiesRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type NameRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *NameRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type UrlRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *UrlRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type ActionsRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *ActionsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type ChecksRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *ChecksRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type ContentsRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *ContentsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type DeploymentsRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *DeploymentsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type IssuesRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *IssuesRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type PackagesRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *PackagesRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type PullRequestsRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *PullRequestsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type RepositoryProjectsRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *RepositoryProjectsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type SecurityEventsRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *SecurityEventsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type StatusesRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *StatusesRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type BranchesRaw struct {
	Raw *yaml.Node
	Value []string
}


func (node *BranchesRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type BranchesIgnoreRaw struct {
	Raw *yaml.Node
	Value []string
}


func (node *BranchesIgnoreRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type PathsRaw struct {
	Raw *yaml.Node
	Value []string
}


func (node *PathsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type PathsIgnoreRaw struct {
	Raw *yaml.Node
	Value []string
}


func (node *PathsIgnoreRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type TagsRaw struct {
	Raw *yaml.Node
	Value []string
}


func (node *TagsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type TagsIgnoreRaw struct {
	Raw *yaml.Node
	Value []string
}


func (node *TagsIgnoreRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type ShellRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *ShellRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type WorkingDirectoryRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *WorkingDirectoryRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type ConcurrencyRaw struct {
	Raw *yaml.Node
	Value interface{}
}


func (node *ConcurrencyRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type DefaultsRaw struct {
	Raw *yaml.Node
	Value *Defaults
}


func (node *DefaultsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type EnvRaw struct {
	Raw *yaml.Node
	Value *Env
}


func (node *EnvRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type JobsRaw struct {
	Raw *yaml.Node
	Value *Jobs
}


func (node *JobsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type NameRaw struct {
	Raw *yaml.Node
	Value string
}


func (node *NameRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type OnRaw struct {
	Raw *yaml.Node
	Value interface{}
}


func (node *OnRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}


type PermissionsRaw struct {
	Raw *yaml.Node
	Value interface{}
}


func (node *PermissionsRaw) UnmarshalYAML(value *yaml.Node) error {
	node.Raw = value
	return value.Decode(&node.Value)
}

